# HTTP总结

## 1. http是什么
**HTTP是一个在计算机世界里,专门在两点之间传输图片、音频、视频、html等超文本数据的规范和约定**

## 2. http的特点和缺点
**特点**
- 1.可靠传输,因为http基于tcp,tcp可以提供可靠传输
- 2.能传输的文件多样化,可以传输图片、视频、音频等多种数据
- 3.无状态,http不会主动记录通信两点的信息 (可使用cookie / session)
- 4.简单,可扩展性强,报文头部可自由配置,易于学习和理解
- 5.应用广泛和跨平台性,从浏览器到各种app都有着应用
- 6.请求 / 响应模式,在上一个请求被得到响应后才会发出下一个请求 (http队头堵塞)

**缺点**

- 不安全,由于http是明文传输,所以数据在传输过程中可能被篡改
- 无法验证报文的完整性,依旧是报文被篡改的问题
- 由于http是无状态的,无法验证另一方身份,另一方有可能是伪装的
- 无状态,需要额外的维护用户信息,但是因为上面两点又会导致用户信息的不安全
    
## 3. http的组成

http由 首部 - 头部 - 请求正文 组成  

首部格式:  
请求首部: 方法 请求URL HTTP版本    回车换行  
响应首部: HTTP版本 状态码 说明  回车换行  
请求头 / 响应头  回车换行  
------------------------------空行  
请求正文

## 4. http常用头部
[常用头部大全]('https://www.kancloud.cn/spirit-ling/http-study/851882)
> 通用首部
作用（请求报文和响应报文都可能使用）

Cache-Control
控制缓存的行为：no-cache（强制向服务器再次验证）、no-store（不做任何缓存）、max-age=111111（资源可缓存最大时间 秒）、public（客户端、代理服务器都可利用缓存）、private（代理服务器不可用缓存）

Connection
浏览器想要优先使用的连接类型： keep-alive close（开启和关闭持久连接）

Date
创建报文时间

Pragma
只用于请求报文，客户端要求中间服务器不返回缓存的资源

Via
代理服务器相关信息，每经过一个代理服务器就会添加相关信息，用逗号分割

Transfer-Encoding
传输编码方式：chunked分块传输

Upgrade
要求客户端使用的升级协议，需配合Connection: Upgrade一起使用：websocket


> 请求首部
作用（请求报文专用）

Accept
能正确接收的媒体类型：application/json text/plain

Accept-Charset
能正确接收的字符集: unicode-1-1

Accept-Encoding
能正确接收的编码格式列表：gzip deflate

Accept-Language
能正确接收的语言列表：zh-cn,zh;1=0.9,en,1=0.8

Authorization
客户端认证信息：Bearer dSdSdFFlsfdjasd123，一般存token用

Cookie
发送给服务器的Cookie信息

Expect
期待服务端的指定行为

From
请求方邮箱地址

Host
服务器的域名，用于区分单台服务器多个域名的虚拟主机，是HTTP/1.1唯一必须包含的字段。

If-Match
两端资源标记比较，只有判断条件为真服务端才会接受请求：If-Mach: "123456，和服务端文件标记比较

If-Modified-Since
本地资源未修改返回 304（比较时间）

If-None-Match
本地资源未修改返回 304（比较标记）

User-Agent
客户端信息

Max-Forwards
限制可被代理及网关转发的次数

Proxy-Authorization
向代理服务器发送验证信息

Range
请求某个内容的一部分，配合If-Range使用

Referer
请求发起页面的原始URI

TE
传输编码方式

> 响应首部
作用（响应报文专用）

Accept-Ranges
告知客户端服务器是否可接受范围请求，是bytes，否none

Age
资源在代理缓存中存在的时间

ETag
资源标识，资源发生变化时标识也会发生改变

Location
客户端重定向到某个 URL

Proxy-Authenticate
向代理服务器发送验证信息

Server
服务器名字：Apache Nginx

WWW-Authenticate
获取资源需要的认证方案

Set-Cookie
需要存在客户端的信息，一般用于识别用户身份

Transfer-Encoding: chunked
数据不定长传输

> 实体首部
作用（补充请求报文或响应报文相关信息）

Allow
资源的正确请求方式：GET HEAD POST

Content-Encoding
内容的编码格式：gzip deflate

Content-Language
内容使用的语言：zh-CN

Content-Length
request body 长度（即实体主体的大小）：

Content-Location
返回数据的备用地址

Content-MD5
Base64加密格式的内容 MD5检验值

Content-Range
响应主体的内容范围

Content-Type
内容的媒体类型（如'application/json;charset=UTF-8'则会发送预检请求）

Expires
内容的过期时间

Last_modified
内容的最后修改时间


## 5. http常用请求方法

GET: 向服务器请求资源  
POST: 向服务器发送数据  
 **POST请求时首先发送OPTIONS带着post请求头的请求,在响应100 continue后发送POST报文主体**  
HEAD: 请求资源,但是只会返回响应头,使用场景(获取大文件的大小后再决定是否下载)  
PUT: 向服务器发送资源  
DELETE: 删除资源  
PATCH: 用于对资源进行部分修改  
OPTION:获取服务器支持的请求方法  

## 6.说明GET和POST
 1. 参数:   
 GET只接受ASCII码,POST没有限制  
 GET的参数会显示在URL里,而POST请求则在请求主体中  
 GET请求的参数为明文

 2. 缓存:   
 GET请求会主动缓存下来,页面刷新时不会重复请求  
 POST请求不会被缓存下来

 3. 幂等:  
 GET是幂等的,而POST是非幂等的  
 页面刷新后退时,GET安全无害,而POST可能会重复提交等

## 7. http的状态码

2xx 请求被服务器成功处理  
200 请求成功  
204 请求成功但不返回主体

3xx 重定向缓存等  
301 永久重定向,以后访问之前的URL时都会跳转到新的URL  
302 临时重定向,资源临时分配了URL  
303 资源存在于另一个URL,只能用GET方法获取资源
304 协商缓存  
307 临时重定向,和302差不多,但是不能改变原本的请求方法

4xx 请求出错 / 请求非法等  
400 请求出错
401 请求不被允许,需要服务器授权   
403 请求被服务器拒绝  
404 请求的资源未找到  
405 请求的方法不允许  
408 客户端请求超时  
413 请求的数据过大  


5xx 服务器出错   
500 服务器内部发生错误  
501 该请求客户端不支持  
502 上游服务器没有响应  
503 服务器停机或超时,无法处理请求

## 8. cookie和session
 ### cookie
 含义: 由于http是无状态的,但是有时又需要记录用户的状态,于是就有了cookie技术,cookie是浏览器上的一小块存储空间,容量最大为4KB,由于在发送同域http请求时会自动在请求头带上cookie,故就可以用cookie来记录用户的信息 

 特点: 容量最大为4KB,每次在同域请求时会在请求头自动带上,可缓存,可配置  

 缺点:  
 - 容量不够大,能存储的信息有限 解决方法(本地存储stora / 状态管理 session)
 - 增加网络负担,某些请求有时不需要带上cookie,解决方法(域名分片?)
 - 不安全,由于http是明文传输,同时cookie也是明文存储,则cookie可能会被篡改和盗用 (XSS、CSRF攻击)


 ### session
 含义:由于cookie的不安全,小容量等缺点,从而诞生了session技术,session是存储在服务器上的一块空间,每一块session都会对应一个sessionID,然后使用cookie保存sessionID,这样在传输时中间人无法得知具体的用户信息,同时也能产生像cookie一样的效果,有效解决了cookie的痛点

 特点:  
 - 由于部署在服务器上,故容量应比cookie大的多
 - 安全性高,只需要存储对应的sessionID,不用明文存储用户信息
 - 减轻网络负担,cookie存储的东西变少

 缺点:由于session是存储在服务器上的,这样会给服务器带来负担


## 9. http各个版本
http 0.9  
http 1.0  
http 1.1  支持长连接(keep-alive) 支持管道传输(为了解决http队头堵塞)
http 2 首部压缩(对应的字典和哈希表) 服务器主动推送 二进制分帧(解决http队头堵塞) 请求优先级


## 10. http1.1如何解决队头堵塞

### 什么是http队头堵塞
HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的HTTP队头阻塞问题。

### 并发连接
对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个

### 域名分片
一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。
比如 content1.sanyuan.com 、content2.sanyuan.com。
这样一个sanyuan.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

## 9. 解释https

### 出现原因
由于http 无法验证报文完整性、无法确定报文传输目标的合法性和无法保证报文在传输中不被篡改等种种安全问题,于是就出现了http的安全版,https  

### https原理
https是在网络层上加了一层SSL/TLS加密层

**对称加密**
加密和解密用的都是同一个秘钥  
优点:加密和解密的速度快,效率高  
缺点:有安全隐患,任意一个秘钥被获取都会使整个加密方式失效   


**非对称加密**
采用公钥 / 私钥加密, 然后对用的 私钥 / 公钥 解密  
优点:这样的加密方式很安全,只有 私钥 / 公钥 能解密  
缺点:解密的效率大大不如对称加密


**https加密:**

服务器发送自己的非对称加密的加密公钥给客户端,然后客户端使用这把公钥加密之后用以通信的对称加密密钥,服务器接收到后,用自己的私钥来解开之公钥加密的对称加密密钥,之后双方就可以约定好,一起使用对称加密密钥来加密通信

**[https加密参考](https://juejin.im/post/5e648d566fb9a07c7d006cf3#heading-4)**  


**数字证书**  

数字证书出现的原因:   
服务器发送给客户端的非对称加密公钥有可能会被中间人截取,然后替换成中间人自己的公钥,客户端用的非对称加密公钥就是中间人而不是服务器的,但是还是依旧用了错误的公钥了加密对称加密的秘钥发送,此时数据又被截取,这时https加密通信的对称秘钥就被暴露,整个加密流程失效

数字证书是什么:  

- 服务器信息 : 服务器的**非对称加密**,采用的hash加密算法,公钥域名,所有者,地址...等信息
- 信息摘要 : 服务器经过 **hash** 加密后的hash串
- 机构加密的信息摘要 : 第三方CA机构会用自己的私钥对信息摘要进行加密成的hash串
- 数字证书: 由 服务器信息 + 机构加密的信息摘要 组成

证书如何验证:  
1. 服务器会在首次通信时将自己的证书发送给客户端
2. 客户端有着内置CA的解密私钥
3. 客户端接收到数字证书后,提取里面的服务器信息,利用同样的hash得到信息摘要hash串,再利用解密私钥解密机构加密的信息摘要得到hash串,两者对比,不同则有泄露风险,一致则说明接收到的服务器信息是正确的,可以使用https


![avatar](https://user-gold-cdn.xitu.io/2020/3/8/170b8c8ecdf1da81?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

##  http/2

1. 头部压缩:   
HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。  
这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

2. 二进制格式  
HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。
这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。

3. 数据流  
HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。  
每个请求或回应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数  
客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。  

4. 多路复用  
HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。
移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。  
举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。  

5. 服务器推送  
HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。  
举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。





