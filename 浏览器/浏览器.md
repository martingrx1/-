# 浏览器

[参考](https://juejin.im/post/5a6547d0f265da3e283a1df7)

## 1. 浏览器包括哪些进程
- 主进程 管理调度各个页面
- 浏览器内核(渲染进程) 一个tab页一个
- GPU进程 3D绘制
- 插件进程

### 多进程的优点
1. 任意一个页面 / 进程 崩溃不会影响整个浏览器的使用
2. 第三方插件奔溃也不会浏览器使用   
3. 充分利用了多核CPU的优势


## 2. 浏览器的渲染进程

### 包括哪些线程
1. GUI渲染线程      
    - 负责页面的布局和绘制,解析HTML和CSS生成render Tree
    - 当页面发生重绘或者回流,这个线程就会执行
    - 与JS引擎线程是互斥的,一个执行另一个会挂起

2. JS引擎线程
    - 负责页面 JS脚本的解析和执行
    - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
    - 与GUI渲染线程是互斥的,一个执行另一个会挂起
    -  
3. 事件线程(管理事件队列)
    - 归属于浏览器而不是JS引擎，用来控制事件循环
    - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
    - 当JS执行异步任务时,会将异步任务添加进入事件线程中
4. 定时器线程
    - 传说中的setInterval与setTimeout所在线程
    - 浏览器定时计数器并不是由JavaScript引擎计数的,因为JS是单线程会堵塞影响计时
    - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）

5. 网络请求线程
    - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
    - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

## 3. JS引擎线程 和 渲染线程

### 1. 为什么会互斥
由于js是可以操作dom的,如果在修改元素时同时渲染页面,那么渲染后获取的元素数据可能就不一致了
(比如 div宽度900,渲染中js修改成800,但是最后渲染出来的还是900,这样元素的属性就不一致了)

### 2. js堵塞页面
由于js引擎 和 渲染线程 互斥, 假如 js引擎运行的时间过长,那么渲染引擎就一直无法执行,这时就会出现页面加载堵塞

### 3. web Worker
- 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
- JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect!



## 4.从输入URL -> 浏览器渲染 期间发生了什么

### 1. 网络请求
    1. 输入URL,浏览器解析URL并构建请求行
    2. 查找强缓存,若命中直接使用,否则进入下一步
    3. DNS解析,获取URL对应的IP地址 (浏览器提供DNS解析缓存功能,若有缓存则直接使用缓存好的对应IP地址)
    4. 建立TCP连接, 三次握手
    5. 发送HTPP请求, (请求行 请求头 请求体POST方法存在)
    6. 服务器网络响应 (响应行 响应头 响应头)

### 2. 浏览器渲染流程(解析HTML 和 CSS)

2.1 构建 DOM 树  (标记化 建树)
 
2.2 解析CSS代码 (格式化 标准化 计算规则)

2.3  DOM树 和 CSS解析生成的css树 合并 成 layout 树

### 3. 浏览器渲染流程(渲染过程)

**3.1 建立图层树**   

合成层(复合图层):
>   首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）  
其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。  
然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源  （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）  
可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒


生成复合图层(显示合成):
- HTML根元素本身就具有层叠上下文。
- 普通元素设置position不为static并且设置了z-index属性，会产生层叠上下文。
- 元素的 opacity 值不是 1
- 元素的 transform 值不是 none
- 元素的 isolation 值是isolate
- will-change指定的属性值为上面任意一个。(will-change的作用后面会详细介绍)

隐式合成:  
简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意

**3.2 生成绘制列表**   
接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。

**3.3 生成图块和位图**   


**3.4 显示器显示内容 (发送给GPU绘制)**   

## 4.浏览器重绘和回流

### 重绘
当元素的几何形状,位置没有改变,单纯只改变颜色,字体等时  
**重绘过程**
只会经过上面的计算样式和生成绘制列表,然后进行生成位图、分块等后面操作

重绘不会触发回流


### 回流
**怎么样会触发回流**

一个 DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等

使 DOM 节点发生增减或者移动。

读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。

调用 window.getComputedStyle 方法。

**回流过程**

触发回流后,DOM的结构会发生改变,于是就会重新构建DOM树,上面的浏览器渲染解析和渲染重新走一遍,开销非常大  
回流一定触发重绘


## 5. 渲染完成后发生什么
 1. 渲染完成会触发load事件  
 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。  
 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。  

 2. JS开始加载,解析,创建执行环境,事件循环  

 ## 6. JS的事件循环



