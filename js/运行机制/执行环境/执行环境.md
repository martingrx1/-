# JS的执行环境
[参考1](https://www.cxymsg.com/guide/mechanism.html#javascript%E6%89%A7%E8%A1%8C)  
[参考2](https://juejin.im/post/5bdfd3e151882516c6432c32#heading-7)
## 1. JS的数据是如何被保存的
基本数据类型 -> 栈  
引用类型 -> 堆  

## 2. 什么是执行上下文 
简而言之，执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行,相当于函数等的载体。

### 执行上下文的类型  
- 全局执行上下文 : 所有的代码都是在全局执行上下文中执行的 ,全局执行上下文做了两件事,1. 创建全局window对象 2.设置默认的全局 this 值指向window对象
- 函数执行上下文 : 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建,都会压入执行栈中。
- Eval 执行上下文 — 执行在 eval 内部的代码也会有它属于自己的执行上下文，除非你想搞黑魔法，不然不要轻易使用它

### 执行上下文是如何被创建的
1. this绑定
2. 词法环境被创建
3. 变量环境被创建

 **this绑定** 

 在全局的执行上下文中, this的指向为全局对象,在浏览器中为window对象  

 在函数执行上下文中, this的指向取决于调用它的对象 和 this绑定方法(apply,call,bind), 在非严格模式下,函数若没有被对象调用也没有被apply等方法绑定,将会默认指向全局对象,浏览器中是window,在严格模式中,默认的this指向underfined

 **词法环境创建**  
词法环境是一个包含标识符变量映射的结构。（这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用）, 简单来说,就是用于保存变量的地方  

词法环境的组成 :
1. 环境记录器 : 是用于存储当前执行上下文的变量(let const) 和 函数声明的地方
2. 外部环境的引用 : 函数作用域链作用, 用于引用上级(外部)的词法环境

环境记录器分为两种 :
1. 声明性环境记录(函数) : 存储变量、函数和参数。一个函数环境包含声明性环境记录。
2. 对象环境记录(全局) : 用于定义在全局执行上下文中出现的变量和函数的关联。全局环境包含对象环境记录。

词法环境有两种 :
1. 全局词法环境 : 环境记录器储存全局变量 和 全局函数声明 , 外部环境的引用为 NULL
2. 函数词法环境 : 用户在函数中定义的变量被存储在环境记录中。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。

注意： 对于函数环境而言，环境记录器 还包含了一个 arguments 对象，该对象包含了索引和传递给函数的参数之间的映射以及传递给函数的参数的长度（数量）。例如，下面函数的 arguments 对象如下所示：
```
function foo(a, b) {  
  var c = a + b;  
}  
foo(2, 3);

// arguments 对象  
Arguments: {0: 2, 1: 3, length: 2},

```

**变量环境**  

与词法环境大致相同, 不同点在于 词法环境记录的是 let 和 const 声明的变量和函数绑定, 变量环境记录的是 var 声明的变量和函数绑定

例子 : 
```
let a = 20;  
const b = 30;  
var c;

function multiply(e, f) {  
 var g = 20;  
 return e * f * g;  
}

c = multiply(20, 30);
```

执行上下文如下所示：

```
GlobalExectionContext = {

  ThisBinding: <Global Object>,

  LexicalEnvironment: {  
    EnvironmentRecord: {  
      Type: "Object",  
      // 标识符绑定在这里  
      a: < uninitialized >,  
      b: < uninitialized >,  
      multiply: < func >  
    }  
    outer: <null>  
  },

  VariableEnvironment: {  
    EnvironmentRecord: {  
      Type: "Object",  
      // 标识符绑定在这里  
      c: undefined,  
    }  
    outer: <null>  
  }  
}

FunctionExectionContext = {  
   
  ThisBinding: <Global Object>,

  LexicalEnvironment: {  
    EnvironmentRecord: {  
      Type: "Declarative",  
      // 标识符绑定在这里  
      Arguments: {0: 20, 1: 30, length: 2},  
    },  
    outer: <GlobalLexicalEnvironment>  
  },

  VariableEnvironment: {  
    EnvironmentRecord: {  
      Type: "Declarative",  
      // 标识符绑定在这里  
      g: undefined  
    },  
    outer: <GlobalLexicalEnvironment>  
  }  
}

```

### 变量提升  
由上述代码,我们就可以知道变量提示的原理了, 在全局变量 / 函数被创建时 , 首先记录其中变量声明 和 函数声明,其中可见 
- var 变量首先被赋值为了undefined ,直到执行了 var 变量赋值那一段var才有确切的值
- let 和 const 变量是uninitialized , 在没有执行到赋值的那一行时该变量不能访问,这就是暂时性锁区
- 函数会直接被正确赋值
      
## 2. 什么是调用栈 / 执行栈

用于存储在JS运行期间所创建的所有执行上下文,通俗来讲,就是控制js函数的调用,每当有函数调用都会将该函数执行上下文压入栈顶,轮到该函数执行完后将该函数的执行上下文出栈

 1. js在读取脚本时,会首先创建一个全局执行上下文压入执行栈中,直到JS程序结束才弹出
 2. 每当发生一个函数调用,都会为该函数创建一个新的执行上下文,并压入执行栈中
 3. js引擎会运行执行栈顶端的函数,当函数运行完成后,其执行上下文从执行栈中弹出
 4. 弹出的执行上下文占用的空间会被垃圾回收机制回收 (特殊情况 闭包)
 5. 上下文控制权转移给执行栈中的下一个执行上下文

 ### 闭包的产生

 什么是闭包 :  一个函数A内的变量可以由他所返回的函数B一直访问着,而不会随着A函数结束而销毁  
 原因: 返回的**函数B词法作用域外部引用** 引用到了 **函数A的词法作用域** ,本身函数A运行结束会被销毁的执行上下文就被保存了下拉,于是就产生了闭包,函数B可以一直访问到函数A的变量

## 4. 一段JS代码是如何执行的

1. 加载js文件, 词法分析生成token,语法分析生成AST树
2. 生成执行上下文,全局执行上下文入栈 ?
2. 解释器将 AST 树生成为 V8 字节码 , 逐行解析执行 , 遇到重复率高的代表直接编译保存为机器码使用 
4. js开始执行 , 事件循环 垃圾回收等