# JS加载和解析

## 1.生成AST树

### 词法分析
词法分析即分词，它的工作就是将一行行的代码分解成一个个token。 比如下面一行代码:
```
let name = 'sanyuan'
```
let :  关键字  
name : 变量名  
= : 赋值  
'sanyaun' : 字符串  

即解析成了四个token，这就是词法分析的作用。

### 语法分析

将词法分析的 token 转换成一定规则的AST对象树  
当生成了 AST 之后，编译器/解释器后续的工作都要依靠 AST 而不是源代码。

![avatar](http://47.98.159.95/my_blog/week07/8.jpg)

## 2. 生成执行上下分
**在执行环境一章中**

## 2.生成字节码

字节码是介于机器码和JS代码中的一种代码,是由 V8的解释器来生成的

### 为什么要生成字节码
因为机器码的体积过于庞大,而字节码相对来说就小巧许多,避免了内存占用问题

字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。

## 3.执行代码
接下来，就进入到字节码解释执行的阶段啦！

在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做热点代码(HotSpot)，然后将这么代码编译成机器码保存起来，这个用来编译的工具就是V8的编译器(也叫做TurboFan) , 因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为热点代码，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。

其实当你听到有人说 JS 就是一门解释器语言的时候，其实这个说法是有问题的。因为字节码不仅配合了解释器，而且还和编译器打交道，所以 JS 并不是完全的解释型语言。而编译器和解释器的 根本区别在于前者会编译生成二进制文件但后者不会。

并且，这种字节码跟编译器和解释器结合的技术，我们称之为即时编译, 也就是我们经常听到的JIT。

这就是 V8 中执行一段JS代码的整个过程，梳理一下:

1. 首先通过词法分析和语法分析生成 AST
2. 将 AST 转换为字节码
3. 由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率